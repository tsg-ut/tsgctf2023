from output import public_key, ciphertext
from sage.modules.free_module_integer import IntegerLattice

p = 0xfffffffffffffffffffffffffffffffeffffffffffffffff
F = GF(p)
d = 100
n = 10
q = p // (2 ** 64)

A, T = public_key
A = matrix(F, A)
T = vector(F, T)

N = 2 ** 64

t = 2

flag = b''

for (U, v) in ciphertext:
  U = vector(F, U)
  v = F(v)

  M = []

  for i in range(d):
    g = [0 for _ in range(d + t)]
    for j in range(t):
      g[j] = int(A[i][j]) * N
    g[i + t] = 2
    M.append(g)

  g = [0 for _ in range(d + t)]
  for i in range(t):
    g[i] = -int(U[i]) * N
  for i in range(d):
    g[i + t] = -1
  M.append(g)

  for i in range(t):
    g = [0 for _ in range(d + t)]
    g[i] = p * N
    M.append(g)

  print('LLL start')
  lattice = IntegerLattice(M, lll_reduce=True)
  print('LLL end')

  E = lattice.reduced_basis

  ok = False
  r_recovered = None
  for g in E:
    if g[0] == 0 and all(x == 1 or x == -1 for x in g[t:]):
      r_recovered = vector([F((x + 1) // 2) for x in g[t:]])
      print(r_recovered)
      print((r_recovered * A)[0:3])
      print(U[0:3])
      if U == r_recovered * A:
        ok = True
        break

  if not ok:
    print('attack failed')
    exit()

  m = (v - r_recovered * T) / q
  flag += int(m).to_bytes(8, 'big')

  print(flag)

'''
for r in E:
  ok = True
  for k in range(1, m):
    if r[k] % 2 == 0:
      ok = False
      break
  if ok:
    print(r)

    R = vector([F((r[i + 1] + 1) // 2) for i in range(m)])
    A0 = matrix([[A[i][0]] for i in range(m)])
    A1 = matrix([[A[i][1]] for i in range(m)])
    print(R * A0)
    print(U[0])
    print(R * A1)
    print(U[1])
'''


'''
# Attack

from sage.modules.free_module_integer import IntegerLattice
At = matrix(A).transpose()
print(At[0])
res = vector(F, [F(0) for _ in range(m)])
for a, s in zip(At, private_key):
  res += vector(F, a) * s
B = []
for i in range(m):
  r = [0 for _ in range(m)]
  r[i] = p
  B.append(r)

print('LLL start')
lattice = IntegerLattice([*At.rows(), *B], lll_reduce=True)
print('LLL end')
E = lattice.reduced_basis
print(lattice)
print(E)

# Babai's Nearest Plane algorithm
# from: http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/
def Babai_closest_vector(M, G, target):
  small = target
  for _ in range(1):
    for i in reversed(range(M.nrows())):
      c = ((small * G[i]) / (G[i] * G[i])).round()
      small -= M[i] * c
  return target - small

gram = E.gram_schmidt()[0]
res = Babai_closest_vector(E, gram, vector(ZZ, T))

print(res)

recovered_e = res - vector(ZZ, T)

print(recovered_e)
print(e)
'''
